declare const canvas: HTMLCanvasElement;
declare const ctx: CanvasRenderingContext2D;
declare let W: number;
declare let H: number;
declare function circle(x: number, y: number, radius: number, color?: string, lineWidth?: number): void;
declare function clear(x?: number, y?: number, width?: number, height?: number): void;
declare function fill(color?: string): void;
declare function getPixel(x: number, y: number): [r: number, g: number, b: number, a: number];
declare const _images: {};
declare function _loadImage(path: string): Promise<void>;
declare function image(path: string, x?: number, y?: number, width?: number, height?: number): Promise<void>;
declare function polygon(points: [x: number, y: number][], color?: string, lineWidth?: number): void;
declare function line(x1: number, y1: number, x2: number, y2: number, color?: string, lineWidth?: number): void;
declare function rectangle(x: number, y: number, width: number, height: number, color?: string, lineWidth?: number): void;
declare function text(value: any, x?: number | [number, "left" | "center" | "right"], y?: number, font?: string | number, color?: string, lineWidth?: number): void;
declare function triangle(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, color?: string, lineWidth?: number): void;
declare const keyboard: {
    readonly pressed: boolean;
    readonly keyName: string;
    readonly keys: {
        [keyName: string]: boolean;
    };
    enter: boolean;
    space: boolean;
    left: boolean;
    up: boolean;
    right: boolean;
    down: boolean;
    a: boolean;
    b: boolean;
    c: boolean;
    d: boolean;
    e: boolean;
    f: boolean;
    g: boolean;
    h: boolean;
    i: boolean;
    j: boolean;
    k: boolean;
    l: boolean;
    m: boolean;
    n: boolean;
    o: boolean;
    p: boolean;
    q: boolean;
    r: boolean;
    s: boolean;
    t: boolean;
    u: boolean;
    v: boolean;
    w: boolean;
    x: boolean;
    y: boolean;
    z: boolean;
};
declare let _keyName: string;
declare let _keys: {};
declare const mouse: {
    readonly x: number;
    readonly y: number;
    readonly over: boolean;
    left: boolean;
    right: boolean;
    readonly buttons: readonly boolean[];
};
declare let _mouseX: number;
declare let _mouseY: number;
declare let _mouseOver: boolean;
declare let _buttons: any[];
declare const touchscreen: {
    readonly x: any;
    readonly y: any;
    readonly touches: readonly {
        readonly x: number;
        readonly y: number;
        readonly identifier: number;
    }[];
    readonly touched: boolean;
};
declare let _touches: any[];
declare function _touchHandler(event: TouchEvent): void;
declare class Cell {
    readonly row: number;
    readonly column: number;
    readonly x: number;
    readonly y: number;
    readonly width: number;
    readonly height: number;
    private _textColor;
    private _color;
    private _image;
    private _text;
    private _custom;
    tag: any;
    constructor(row: number, column: number, x: number, y: number, width: number, height: number, _textColor: string);
    get color(): string;
    set color(value: string);
    get image(): string;
    set image(value: string);
    get text(): string;
    set text(value: string | [value: string, color: string]);
    get textColor(): string;
    get custom(): (cell: Cell) => void;
    set custom(value: (cell: Cell) => void);
    draw(): Promise<void>;
}
declare class Grid {
    readonly rows: number;
    readonly columns: number;
    readonly x: number;
    readonly y: number;
    readonly width: number;
    readonly height: number;
    private color;
    private lineWidth;
    private activatable;
    private _activeCell;
    private cells;
    private cellWidth;
    private cellHeight;
    constructor(rows: number, columns: number, x?: number, y?: number, width?: number, height?: number, color?: string, lineWidth?: number);
    cell(rowIndex: number, columnIndex: number): Cell;
    forEach(callback: (cell: Cell) => void): void;
    get activated(): boolean;
    get activeCell(): Cell;
    cellFromPoint(x: number, y: number): Cell;
    draw(): void;
}
declare class Hitbox {
    x: number;
    y: number;
    width: number;
    height: number;
    tag: any;
    constructor(x: number, y: number, width: number, height: number);
    intersects(other: Hitbox): boolean;
    contains(x: number, y: number): boolean;
    drawOutline(color?: string): void;
}
declare class Sprite extends Hitbox {
    private spritesheetPath;
    private rows;
    private columns;
    private loop;
    private frames?;
    private index;
    private frameTime;
    private remainingTime;
    constructor(spritesheetPath: string, rows?: number, columns?: number, loop?: boolean, frames?: number[]);
    set framesPerSecond(value: number);
    get framesPerSecond(): number;
    update(): Promise<void>;
    getImages(): Promise<string[]>;
}
declare class Turtle {
    private x;
    private y;
    private heading;
    private container;
    private turtle;
    private points;
    private _color;
    delay: number;
    constructor(x?: number, y?: number, heading?: number);
    get state(): [x: number, y: number, heading: number];
    set state(value: [x: number, y: number, heading: number]);
    get color(): string;
    set color(value: string);
    private move;
    private turn;
    forward(length: number, trace?: boolean): Promise<void>;
    backward(length: number, trace?: boolean): Promise<void>;
    right(degAngle?: number): Promise<void>;
    left(degAngle?: number): Promise<void>;
    hide(): void;
    beginFill(): void;
    endFill(): void;
}
declare let DT: number;
declare let _update: () => void;
declare let _timestamp0: number;
declare function _updateHandler(timestamp: number): void;
declare function setUpdate(update?: () => void): void;
declare function array(length: number): any[];
declare function array<T>(length: number, callback: ((index?: number) => T)): T[];
declare function array<T>(length: number, value: Exclude<T, Function>): T[];
declare function array2D(rows: number, columns: number): any[][];
declare function array2D<T>(rows: number, columns: number, callback: ((rowIndex?: number, columnIndex?: number) => T)): T[][];
declare function array2D<T>(rows: number, columns: number, value: Exclude<T, Function>): T[][];
declare let _audioContext: AudioContext;
declare const _audioList: [OscillatorNode, GainNode][];
declare function beep(frequency?: number, msDuration?: number, volume?: number): Promise<void>;
declare function char(charCode: number): string;
declare function charCode(char: string): number;
declare function degrees(radAngle: number): number;
declare function distance(x1: number, y1: number, x2: number, y2: number): number;
declare function pointFromPolar(radius: number, degAngle: number, x0?: number, y0?: number): [x: number, y: number];
declare function radians(degAngle: number): number;
declare function randomInt(min: number, max: number): number;
declare function randomInt(limit: number): number;
declare function randomItem<T>(...items: T[]): T;
declare function rgba(r: number, g: number, b: number, a?: number): string;
declare function shuffle(array: any[]): void;
declare function sleep(msDuration: number): Promise<void>;
declare class Vector {
    x: number;
    y: number;
    constructor(x: number, y: number);
    static fromPolar(length: number, angle: number): Vector;
    get length(): number;
    set length(value: number);
    get angle(): number;
    set angle(value: number);
    clone(): Vector;
    normalize(): void;
    toNormalized(): Vector;
    add(v: Vector): void;
    toAdded(v: Vector): Vector;
    subtract(v: Vector): void;
    toSubtracted(v: Vector): Vector;
    multiply(v: Vector): void;
    toMultiplied(v: Vector): Vector;
    divide(v: Vector): void;
    toDivided(v: Vector): Vector;
    scale(s: number): void;
    toScaled(s: number): Vector;
    distanceTo(v: Vector): number;
    directionTo(v: Vector): Vector;
    dot(v: Vector): number;
    toString(): string;
}
declare const io: HTMLDivElement;
declare const _params: URLSearchParams;
declare const _iParam: string;
declare let _inputLines: string[];
declare let _inputLineIndex: number;
declare let _output$: HTMLDivElement;
declare let _outputValue: string;
declare function read(prompt?: string): Promise<string>;
declare function write(value?: any, newLine?: boolean): void;
declare function writeJSON(value: any): void;
declare function clearIO(): void;
declare const ui: HTMLDivElement;
declare function resetCanvas(): void;
type _InputType = "checkbox" | "color" | "date" | "datetime-local" | "file" | "number" | "password" | "radio" | "range" | "time";
type _TagNameMap = HTMLElementTagNameMap & {
    [key in `input:${_InputType}`]: HTMLInputElement;
};
interface TagNameMap extends _TagNameMap {
}
type _VoidElement = "area" | "base" | "br" | "col" | "command" | "embed" | "hr" | "img" | "input" | `input:${_InputType}` | "keygen" | "link" | "meta" | "param" | "source" | "track" | "wbr";
type LabableElement = "input" | `input:${_InputType}` | "meter" | "output" | "progress" | "select" | "textarea";
declare function element<K extends keyof Omit<TagNameMap, _VoidElement | LabableElement>>(tagName: K, textContent?: string, parent?: HTMLElement, before?: Node): TagNameMap[K];
declare function element<K extends keyof Pick<TagNameMap, LabableElement>>(tagName: K, label?: string | [string, ...("top" | "right" | "bottom" | "left" | "block" | "inline")[]], parent?: HTMLElement, before?: Node): TagNameMap[K];
declare function element<K extends keyof TagNameMap>(tagName: K, parent?: HTMLElement, before?: Node): TagNameMap[K];
declare function _getLegend(elt: HTMLElement): string;
declare function getLabel(labeledElement: HTMLElement): string;
declare function setLabel(labeledElement: HTMLElement, value: string): void;
declare function setLocation(elt: HTMLElement, settings: {
    left?: number | string;
    right?: number | string;
    top?: number | string;
    bottom?: number | string;
}): void;
declare let _errNr: number;
declare const _error$: HTMLOutputElement;
